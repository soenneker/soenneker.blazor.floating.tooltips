@using System.Threading
@using Microsoft.JSInterop
@using Soenneker.Blazor.Floating.Tooltips.Abstract
@using Soenneker.Blazor.Floating.Tooltips.Options
@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Blazor.Floating.Tooltips.Enums
@using Soenneker.Extensions.CancellationTokens
@using Soenneker.Extensions.String

@inject IFloatingTooltipInterop TooltipInterop

@inherits Soenneker.Quark.Components.Core.Cancellable.CoreCancellableElement
@implements IFloatingTooltip

<CascadingValue Value="this" >
    <div id="@($"anchor-{Id}")" class="floating-tooltip-anchor" @attributes="AnchorAttributes" >
        @ChildContent
    </div>

    @if (_initialized)
    {
        <div id="@($"tooltip-{Id}")" @attributes="Attributes">
            @ResolvedContent
        </div>
    }
</CascadingValue>

@code {
    
    [Parameter]
    public Dictionary<string, object?>? AnchorAttributes { get; set; }
    
    private RenderFragment? _tooltipContent;

    [Parameter]
    public string? Text { get; set; }

    [Parameter]
    public override string? Id { get; set; } = "ft-" + Guid.NewGuid();

    [Parameter]
    public EventCallback OnShow { get; set; }

    [Parameter]
    public EventCallback OnHide { get; set; }

    [Parameter]
    public FloatingTooltipOptions Options { get; set; } = new();

    [Parameter]
    public FloatingTooltipPlacement? Placement { get; set; }

    [Parameter]
    public bool? Animate { get; set; }

    [Parameter]
    public int? ShowDelay { get; set; }

    [Parameter]
    public int? HideDelay { get; set; }

    [Parameter]
    public bool? ShowArrow { get; set; }

    [Parameter]
    public bool? Interactive { get; set; }

    [Parameter]
    public bool? Enabled { get; set; }

    [Parameter]
    public FloatingTooltipTheme? Theme { get; set; }

    [Parameter]
    public bool? ManualTrigger { get; set; }

    [Parameter]
    public bool? UseCdn { get; set; }

    private FloatingTooltipOptions MergedOptions => new()
    {
        Placement = Placement ?? Options.Placement,
        Animate = Animate ?? Options.Animate,
        ShowDelay = ShowDelay ?? Options.ShowDelay,
        HideDelay = HideDelay ?? Options.HideDelay,
        ShowArrow = ShowArrow ?? Options.ShowArrow,
        Interactive = Interactive ?? Options.Interactive,
        Enabled = Enabled ?? Options.Enabled,
        Theme = Theme ?? Options.Theme,
        ManualTrigger = ManualTrigger ?? Options.ManualTrigger,
        UseCdn = UseCdn ?? Options.UseCdn
    };

    private bool _initialized;
    private bool _createPending;
    private DotNetObjectReference<FloatingTooltip>? _dotNetRef;

    private RenderFragment? ResolvedContent =>
        _tooltipContent != null
            ? _tooltipContent
            : (Text.HasContent()
                ? (__builder =>
                {
                    __builder.OpenElement(0, "div");
                    __builder.AddAttribute(1, "class", "tooltip-text");
                    __builder.AddContent(2, Text);
                    __builder.CloseElement();
                })
                : null);

    [JSInvokable]
    public async Task InvokeOnShow()
    {
        await OnShow.InvokeIfHasDelegate();
    }

    [JSInvokable]
    public async Task InvokeOnHide()
    {
        await OnHide.InvokeIfHasDelegate();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await TooltipInterop.Initialize(MergedOptions.UseCdn, CancellationToken.None);
            _dotNetRef = DotNetObjectReference.Create(this);
            _initialized = true;
            _createPending = true;
            StateHasChanged();
            return;
        }

        if (_createPending)
        {
            _createPending = false;
            await TooltipInterop.Create(Id, MergedOptions, CancellationToken.None);
            await TooltipInterop.SetCallbacks(Id, _dotNetRef!);
        }
    }

    public async ValueTask Show(CancellationToken cancellationToken = default)
    {
        if (!_initialized)
            return;

        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            await TooltipInterop.Show(Id, linked);
    }

    public async ValueTask Hide(CancellationToken cancellationToken = default)
    {
        if (!_initialized)
            return;

        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            await TooltipInterop.Hide(Id, linked);
    }

    public async ValueTask Toggle(CancellationToken cancellationToken = default)
    {
        if (!_initialized)
            return;

        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            await TooltipInterop.Toggle(Id, linked);
    }

    protected override void OnParametersSet()
    {
        if (_tooltipContent != null && Text.HasContent())
        {
            throw new InvalidOperationException("Both TooltipContent and Text were set. Use only one.");
        }
    }

    public void SetTooltipContent(RenderFragment content)
    {
        _tooltipContent = content;
    }

    public override async ValueTask DisposeAsync()
    {
        await base.DisposeAsync();

        try
        {
            if (_initialized)
                await TooltipInterop.Destroy(Id, CancellationToken.None);
        }
        catch (JSDisconnectedException) { /* circuit already gone; ignore */ }
        catch (ObjectDisposedException) { /* runtime disposed; ignore */ }

        _dotNetRef?.Dispose();
    }

}
